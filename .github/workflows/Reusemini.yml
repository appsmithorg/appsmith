name: Reuse Actions Mini

on:
  # This line enables manual triggering of this workflow.
  workflow_dispatch:

  # trigger for pushes to release and master
#  push:
#    branches: [release, release-frozen, master]
#    paths:
#      - "app/client/**"
#      - "app/server/**"
#      - "app/rts/**"
#      - "!app/client/cypress/manual_TestSuite/**"

jobs:
  buildClient:
    # If the build has been triggered manually via workflow_dispatch or via a push to protected branches
    # then we don't check for the PR approved state
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push' ||
      (github.event_name == 'pull_request_review' &&
      github.event.review.state == 'approved' &&
      github.event.pull_request.head.repo.full_name == github.repository)
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: app/client
        shell: bash

    steps:
      # Checkout the code
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0

      # Checkout the code
      - id: timestamp
        run: echo "::set-output name=timestamp::$(timestamp +'%Y-%m-%dT%H:%M:%S')"

      - name: Restore the previous run result
        uses: actions/cache@v2
        with:
          path: |
            ~/run_result
          key: ${{ github.run_id }}-${{ github.job }}-${{ steps.timestamp.outputs.timestamp }}
          restore-keys: |
            ${{ github.run_id }}-${{ github.job }}-

      - name: Get the previous run result
        id: run_result
        run: cat ~/run_result 2>/dev/null || echo 'default'

      - name: Restore the previous run failed_spec
        uses: actions/cache@v2
        with:
          path: |
            ~/failed_spec
          key: ${{ github.run_id }}-${{ github.job }}-${{ steps.timestamp.outputs.timestamp }}-${{ matrix.job }}
          restore-keys: |
            ${{ github.run_id }}-${{ github.job }}-${{ matrix.job }}

      - name: Get the previous failed_spec
        id: failed_spec
        run: cat ~/failed_spec 2>/dev/null || echo 'default'

      - uses: actions/checkout@v2
        if: steps.run_result.outputs.run_result != 'success'

      - if: steps.run_result.outputs.run_result != 'success'
        run: echo "Running compelete Action!" && exit 0

      - name: Checkout the merged commit from PR and base branch
        if: github.event_name == 'pull_request_review'
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          ref: refs/pull/${{ github.event.pull_request.number }}/merge

      - name: Checkout the head commit of the branch
        if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - name: Figure out the PR number
        if: steps.run_result.outputs.run_result != 'success'
        run: echo ${{ github.event.pull_request.number }}

      - name: Use Node.js 14.15.4
        if: steps.run_result.outputs.run_result != 'success'
        uses: actions/setup-node@v1
        with:
          node-version: "14.15.4"

      - name: Get yarn cache directory path
        if: steps.run_result.outputs.run_result != 'success'
        id: yarn-dep-cache-dir-path
        run: echo "::set-output name=dir::$(yarn cache dir)"

      # Retrieve npm dependencies from cache. After a successful run, these dependencies are cached again
      #- name: Cache npm dependencies
      #  if: steps.run_result.outputs.run_result != 'success'
      #  id: yarn-dep-cache
      #  uses: actions/cache@v2
      #  env:
      #    cache-name: cache-yarn-dependencies
      #  with:
      #    path: |
      #      ${{ steps.yarn-dep-cache-dir-path.outputs.dir }}
      #    key: ${{ runner.os }}-yarn-dep-${{ hashFiles('**/yarn.lock') }}
      #    restore-keys: |
      #      ${{ runner.os }}-yarn-dep-

      # Install all the dependencies
      #- name: Install dependencies
      #  if: steps.run_result.outputs.run_result != 'success'
      #  run: yarn install

      #- name: Set the build environment based on the branch
      #  if: steps.run_result.outputs.run_result != 'success'
      #  id: vars
      #  run: |
      #    echo "::set-output name=REACT_APP_ENVIRONMENT::DEVELOPMENT"
      #    if [[ "${{github.ref}}" == "refs/heads/master" ]]; then
      #        echo "::set-output name=REACT_APP_ENVIRONMENT::PRODUCTION"
      #    fi
      #    if [[ "${{github.ref}}" == "refs/heads/release" ]]; then
      #        echo "::set-output name=REACT_APP_ENVIRONMENT::STAGING"
      #    fi
      # Since this is an unreleased build, we set the version to incremented version number with
      # a `-SNAPSHOT` suffix.
      #    latest_released_version="$(git tag --list 'v*' --sort=-version:refname | head -1)"
      #    echo "latest_released_version = $latest_released_version"
      #    next_version="$(echo "$latest_released_version" | awk -F. -v OFS=. '{ $NF++; print }')"
      #    echo "next_version = $next_version"
      #    echo ::set-output name=version::$next_version-SNAPSHOT

      # We burn React environment & the Segment analytics key into the build itself.
      # This is to ensure that we don't need to configure it in each installation
      #- name: Create the bundle
      #  if: steps.run_result.outputs.run_result != 'success'
      #  run: |
      #    if [[ $GITHUB_REF == "refs/heads/release" ]]; then
      #      REACT_APP_SEGMENT_CE_KEY=${{ secrets.APPSMITH_SEGMENT_CE_KEY_RELEASE }}
      #    else
      #      REACT_APP_SEGMENT_CE_KEY=${{ secrets.APPSMITH_SEGMENT_CE_KEY }}
      #    fi
      #    REACT_APP_ENVIRONMENT=${{steps.vars.outputs.REACT_APP_ENVIRONMENT}} \
      #      REACT_APP_FUSIONCHARTS_LICENSE_KEY=${{ secrets.APPSMITH_FUSIONCHARTS_LICENSE_KEY }} \
      #      REACT_APP_SEGMENT_CE_KEY="$REACT_APP_SEGMENT_CE_KEY" \
      #      SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }} \
      #      REACT_APP_VERSION_ID=${{ steps.vars.outputs.version }} \
      #      REACT_APP_VERSION_RELEASE_DATE=$(date -u '+%Y-%m-%dT%H:%M:%SZ') \
      #      REACT_APP_GOOGLE_ANALYTICS_ID=${{ secrets.GOOGLE_TAG_MANAGER_ID }} \
      #      REACT_APP_INTERCOM_APP_ID=${{ secrets.APPSMITH_INTERCOM_ID }} \
      #      yarn build
      #    ls -l build
      #- name: Create the dummybundle
      #  if: steps.run_result.outputs.run_result != 'success'
      #  run: |
      #    mkdir -p app/client/build
      #    ls -l app/client/build
      #    echo "::set-output name=run_result::success" > app/client/build/dummybundle
      - name: list failed tests if there are test failures
        run: find /home/runner/work/appsmith/appsmith/app/client/cypress/ -type d|grep spec > ~/failed_spec

      - name: list failed tests if there are test failures 2
        run: find /home/runner/work/appsmith/appsmith/app/client/cypress/ -type d|grep spec >> ~/failed_spec

      - name: print failed_spec
        run: echo ~/failed_spec

      - name: Get failed_spec
        #id: failed_spec_var
        #run: echo ::set-output name=failed_spec::$(cat ~/failed_spec)
        run: |
          failed_spec_env=$(cat ~/failed_spec)
          echo "failed_spec_env<<EOF" >> $GITHUB_ENV
          echo "$failed_spec_env" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      #- name: Test failed_spec
      #  #run: echo ${{ steps.failed_spec_var.outputs.failed_spec }}
      #  run: echo ${{ env.failed_spec_env }}

      #- name: Restore the previous bundle
      #  #if: steps.run_result.outputs.run_result == 'success'
      #  uses: actions/cache@v2
      #  with:
      #    path: |
      #      app/client/build/
      #    key: ${{ github.run_id }}-${{ github.job }}-${{ steps.timestamp.outputs.timestamp }}
      #    restore-keys: |
      #      ${{ github.run_id }}-${{ github.job }}

      # Upload the build artifact so that it can be used by the test & deploy job in the workflow
      #- name: Upload react build bundle
      #  uses: actions/upload-artifact@v2
      #  with:
      #    name: client-build
      #    path: app/client/build/

      - run: echo "::set-output name=run_result::success" > ~/run_result
  ui-test:
    needs: [buildClient]
    # Only run if the build step is successful
    # If the build has been triggered manually via workflow_dispatch or via a push to protected branches
    # then we don't check for the PR approved state
    if: |
      success() &&
      (github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push' ||
      (github.event_name == 'pull_request_review' &&
      github.event.review.state == 'approved' &&
      github.event.pull_request.head.repo.full_name == github.repository))
    runs-on: ubuntu-latest
    defaults:
      run:
        #        working-directory: app/client
        shell: bash
    strategy:
      fail-fast: false
      matrix:
        job: [0, 1, 2]

    steps:
      # Checkout the code
      - id: timestamp
        run: echo "::set-output name=timestamp::$(timestamp +'%Y-%m-%dT%H:%M:%S')"

      - name: Restore the previous run result
        uses: martijnhols/actions-cache@v3
        with:
          path: |
            ~/run_result
          key: ${{ github.run_id }}-${{ github.job }}-${{ steps.timestamp.outputs.timestamp }}-${{ matrix.job }}
          restore-keys: |
            ${{ github.run_id }}-${{ github.job }}-${{ matrix.job }}

      - name: Get the previous run result
        id: run_result
        run: cat ~/run_result 2>/dev/null || echo 'default'

      - name: Restore the previous failed combine result
        if: steps.run_result.outputs.run_result == 'failedtest'
        uses: martijnhols/actions-cache/restore@v3
        with:
          path: |
            ~/combined_failed_spec
          key: ${{ github.run_id }}-"ui-test-result"-${{ steps.timestamp.outputs.timestamp }}
          restore-keys: |
            ${{ github.run_id }}-${{ github.job }}

      - name: Get failed_spec
        #id: failed_spec_var
        #run: echo ::set-output name=failed_spec::$(cat ~/failed_spec)
        if: steps.run_result.outputs.run_result == 'failedtest'
        run: |
          failed_spec_env=$(cat ~/combined_failed_spec)
          echo "failed_spec_env<<EOF" >> $GITHUB_ENV
          echo "$failed_spec_env" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      - name: cat failed_spec
        run: echo ${{ env.failed_spec_env }}

      - name: list failed tests create dir
        if: steps.run_result.outputs.run_result != 'failedtest'
        run: |
          mkdir  ~/failed_spec
          echo  "empty" >> ~/failed_spec/dummy-${{ matrix.job }}

      - name: list failed tests if there are test failures
        if: failure()
        run: |
          echo  "Matrixid=${{ matrix.job }}" >> ~/failed_spec/failed_spec-${{ matrix.job }}

      - name: Accidentally upload to the same artifact via multiple jobs
        uses: actions/upload-artifact@v2
        with:
          name: failed-spec-${{ matrix.job }}
          path: ~/failed_spec

      - uses: actions/checkout@v1
      - name: Try to fail
        run: exit 1

      - name: Print message if we don't fail
        run: echo Should not get here
      - name: Set fail if there are test failures
        if: failure()
        run: echo "::set-output name=run_result::failedtest" > ~/run_result
      - name: Store the previous failed result
        if: always()
        uses: martijnhols/actions-cache/save@v3
        with:
          path: |
            ~/failed_spec
          key: ${{ github.run_id }}-${{ github.job }}-${{ steps.timestamp.outputs.timestamp }}-${{ matrix.job }}
          restore-keys: |
            ${{ github.run_id }}-${{ github.job }}-${{ matrix.job }}
      - name: Store the previous run result
        if: failure()
        uses: martijnhols/actions-cache/save@v3
        with:
          path: |
            ~/run_result
          key: ${{ github.run_id }}-${{ github.job }}-${{ steps.timestamp.outputs.timestamp }}-${{ matrix.job }}
          restore-keys: |
            ${{ github.run_id }}-${{ github.job }}-${{ matrix.job }}
  ui-test-result:
    needs: ui-test
    if: always() &&
      (github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push' ||
      (github.event_name == 'pull_request_review' &&
      github.event.review.state == 'approved' &&
      github.event.pull_request.head.repo.full_name == github.repository))
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    steps:
      - run: echo "All ui-test matrices completed"

      - uses: actions/download-artifact@v2
        if: ${{ failure() }}
        id: download
        with:
          name: failed-spec-0
          path: ~/failed_spec

      - uses: actions/download-artifact@v2
        if: ${{ failure() }}
        id: download-1
        with:
          name: failed-spec-1
          path: ~/failed_spec

      - uses: actions/download-artifact@v2
        if: ${{ failure() }}
        id: download-2
        with:
          name: failed-spec-2
          path: ~/failed_spec

      - name: "Echo download path"
        run: echo ${{steps.download.outputs}}

      - name: "Echo all files"
        run: echo ${{env.failed_spec_env}}

      - name: "combine all specs"
        if: ${{ failure() }}
        run: cat ~/failed_spec/failed_spec* >> ~/combined_failed_spec

      - name: Store the combined run result
        if: ${{ failure() }}
        uses: martijnhols/actions-cache/save@v3
        with:
          path: |
            ~/combined_failed_spec
          key: ${{ github.run_id }}-"ui-test-result"-${{ steps.timestamp.outputs.timestamp }}
          restore-keys: |
            ${{ github.run_id }}-${{ github.job }}

      - name: upload combined failed spec
        if: ${{ failure() }}
        uses: actions/upload-artifact@v2
        with:
          name: combined_failed_spec
          path: ~/combined_failed_spec
