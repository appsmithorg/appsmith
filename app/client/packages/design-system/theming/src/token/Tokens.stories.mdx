import { Canvas, Meta, Story } from "@storybook/addon-docs";
import {
  TokenTable,
  StyledLinePreview,
  StyledSquarePreview,
  StyledTable,
} from "./TokenTable";
import { useThemeContext } from "../theme";
import styled from "styled-components";

<Meta title="Design-system/Theme/Tokens" />

export const StyledWrapper = styled.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  align-self: stretch;
`;

# Tokens

A **design token** is a single source of truth for visual and
functional design decisions. It is an abstract way to represent design
decisions and is used to maintain consistency across a project.

export const RootUnit = () => {
  const { rootUnit } = useThemeContext();
  return (
    <StyledWrapper>
      <h2>Root Unit</h2>
      <h3>What is it?</h3>
      <p>
        We use a fluid root unit to create baseline grid for our design to
        ensure visual consistency and rhythm. The baseline grid is one of the
        most essential layout structures in product design. It makes interfaces
        more consistent, balanced, and easier to scan by users, as it
        establishes a repetitive pattern in visual recognition for your users.
      </p>
      <h3>How to use it?</h3>
      <p>
        To establish a grid system, ensure all sizes, spacing (margins, padding)
        and typography in your designs are multiples of root Unit. As simple as
        that.
      </p>
      <h3>Why fluid?</h3>
      <p>
        We use fluid root unit since the smaller the size of the user viewport,
        the higher the interface density should be, so we change the value of
        the root unit depending on viewport.
      </p>
      <h3>Important</h3>
      <p>
        We do not use root unit value directly for creating components, but only
        derived values are based on it such as spacing, sizing and typography.
      </p>
      <h3>Value</h3>
      <p>{rootUnit}</p>
    </StyledWrapper>
  );
};

## Root Unit

<Canvas withSource="none">
  <Story name="Root Unit">
    <RootUnit />
  </Story>
</Canvas>

export const Sizing = () => {
  const { sizing } = useThemeContext();
  return (
    <StyledWrapper>
      <h2>Sizing</h2>
      <p>
        Sizing is a fundamental aspect of design systems that determines the
        measurements of various elements in a user interface. It refers to the
        process of defining consistent measurements for different components
        such as buttons, icons, typography, and spacing to ensure that they are
        visually balanced and harmonious.
      </p>
      <p>
        We use root unit to calculate values of all sizes since this is a
        fundamental element and used to define the size of all the other
        elements in the system.
      </p>
      <h3>Tokens Table</h3>
      <TokenTable prefix="sizing" tokens={sizing}>
        {(cssVar) => (
          <StyledLinePreview
            style={{
              width: cssVar,
            }}
          />
        )}
      </TokenTable>
    </StyledWrapper>
  );
};

## Sizing

<Canvas withSource="none">
  <Story name="Sizing">
    <Sizing />
  </Story>
</Canvas>

export const Spacing = () => {
  const { spacing } = useThemeContext();
  return (
    <StyledWrapper>
      <h2>Spacing</h2>
      <p>
        Spacing is a crucial aspect of design that can make or break the user
        experience. It helps to create a visual hierarchy, improve readability,
        and make elements of a design easier to understand. A well-thought-out
        spacing system can add clarity and consistency to a design.
      </p>
      <h3>Types of Spacing</h3>
      <p>
        There are two types of spacing in design systems: inner spacing and
        outer spacing.
      </p>
      <h4>Inner Spacing</h4>
      <p>
        Inner spacing, also known as <b>padding</b>, is the space between an
        element's content and its border. It creates room for the content to
        breathe and makes the element more visually appealing.
      </p>
      <h4>Outer Spacing</h4>
      <p>
        Outer spacing, also known as <b>margin</b> and <b>gap</b>, is the space
        between elements. It creates a visual separation between elements and
        contributes to the overall balance of a design.
      </p>
      <h3>Tokens Table</h3>
      <TokenTable prefix="spacing" tokens={spacing}>
        {(cssVar) => (
          <StyledLinePreview
            style={{
              width: cssVar,
            }}
          />
        )}
      </TokenTable>
    </StyledWrapper>
  );
};

## Spacing

<Canvas withSource="none">
  <Story name="Spacing">
    <Spacing />
  </Story>
</Canvas>

export const Color = () => {
  const { color } = useThemeContext();
  return (
    <StyledWrapper>
      <h2>Color</h2>
      <p>
        Color is a crucial element in any design system. It communicates
        information, creates hierarchy, and evokes emotions. Therefore, it is
        essential to establish a consistent and meaningful color palette for
        your design system.
      </p>
      <h3>Semantic Color Naming Strategy</h3>
      <p>
        This naming schema is for the most part inspired by the one shown in The
        hardest part about building dark mode is that people think itâ€™s easy
        talk by
        <a
          href="https://www.youtube.com/watch?v=1DTnojio89Y&t=454s"
          target="_blank"
        >
          Hassan and Jacob Miller at Figma Config 2022
        </a>. This enables flexibility and focuses on deriving these tokens from
        a starting seed rather than assuming those can be hand-picked by a designer.
      </p>
      <StyledTable>
        <thead>
          <tr>
            <th>type</th>
            <th>role (optional)</th>
            <th>prominence (optional)</th>
            <th>state (optional)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>bg</td>
            <td>accent</td>
            <td>regular (default)</td>
            <td>resting (default)</td>
          </tr>
          <tr>
            <td>fg</td>
            <td>neutral</td>
            <td>strong</td>
            <td>hover</td>
          </tr>
          <tr>
            <td>bd</td>
            <td>content</td>
            <td>subtle</td>
            <td>active</td>
          </tr>
          <tr>
            <td></td>
            <td>assistive</td>
            <td></td>
            <td>disabled</td>
          </tr>
          <tr>
            <td></td>
            <td>negative</td>
            <td></td>
            <td>focus</td>
          </tr>
          <tr>
            <td></td>
            <td>positive</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>warning</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>on*</td>
            <td></td>
            <td></td>
          </tr>
        </tbody>
      </StyledTable>
      <h3>Background Tokens Table</h3>
      <TokenTable prefix="color" filter="bg" tokens={color}>
        {(cssVar) => (
          <StyledSquarePreview
            style={{
              background: cssVar,
            }}
          />
        )}
      </TokenTable>
      <h3>Foreground Tokens Table</h3>
      <TokenTable prefix="color" filter="fg" tokens={color}>
        {(cssVar) => (
          <StyledSquarePreview
            style={{
              background: cssVar,
            }}
          />
        )}
      </TokenTable>
      <h3>Border Tokens Table</h3>
      <TokenTable prefix="color" filter="bd" tokens={color}>
        {(cssVar) => (
          <StyledSquarePreview
            style={{
              background: cssVar,
            }}
          />
        )}
      </TokenTable>
    </StyledWrapper>
  );
};

## Color

<Canvas withSource="none">
  <Story name="Color">
    <Color />
  </Story>
</Canvas>

export const BorderRadius = () => {
  const { borderRadius } = useThemeContext();
  return (
    <StyledWrapper>
      <h2>Border Radius</h2>
      <p>
        Border radius is a commonly used design element in user interfaces that
        can add visual interest and depth to a application. By incorporating
        standardized border radius values into our design system, we can create
        a more cohesive and professional look for our products.
      </p>
      <h3>Tokens Table</h3>
      <TokenTable prefix="border-radius" tokens={borderRadius}>
        {(cssVar) => (
          <StyledSquarePreview
            style={{
              borderRadius: cssVar,
            }}
          />
        )}
      </TokenTable>
    </StyledWrapper>
  );
};

## Border Radius

<Canvas withSource="none">
  <Story name="Border Radius">
    <BorderRadius />
  </Story>
</Canvas>

## Box Shadow

export const BoxShadow = () => {
  const { boxShadow } = useThemeContext();
  return (
    <StyledWrapper>
      <h2>Box Shadow</h2>
      <p>
        Box shadow is a visual effect that creates a three-dimensional look on a
        two-dimensional element. It is used in web design to add depth and
        texture to user interfaces. In a design system, box shadow is an
        important element that helps to maintain consistency across all
        components.
      </p>
      <h3>Tokens Table</h3>
      <TokenTable prefix="box-shadow" tokens={boxShadow}>
        {(cssVar) => (
          <StyledSquarePreview
            style={{
              boxShadow: cssVar,
            }}
          />
        )}
      </TokenTable>
    </StyledWrapper>
  );
};

## Box Shadow

<Canvas withSource="none">
  <Story name="Box Shadow">
    <BoxShadow />
  </Story>
</Canvas>

## Opacity

export const Opacity = () => {
  const { opacity } = useThemeContext();
  return (
    <StyledWrapper>
      <h2>Opacity</h2>
      <p>
        Opacity is an important aspect of design system that determines the
        transparency of an element. It is measured in percentage, where 0% is
        completely transparent and 100% is completely opaque. In design system,
        opacity is used to create visual hierarchy, depth, and contrast. By
        adjusting the opacity of an element, designers can create subtle or
        dramatic effects that enhance the user experience.
      </p>
      <TokenTable prefix="opacity" tokens={opacity}>
        {(cssVar) => (
          <StyledSquarePreview
            style={{
              opacity: cssVar,
            }}
          />
        )}
      </TokenTable>
    </StyledWrapper>
  );
};

<Canvas withSource="none">
  <Story name="Opacity">
    <Opacity />
  </Story>
</Canvas>

## Typography

<Canvas withSource="none">
  <Story name="Typography">
    <StyledWrapper>
      <h2>Typography</h2>
      <p>
        To work with typography, we offer a{" "}
        <a href="/?path=/docs/design-system-widgets-text--text">
          Text component
        </a>
        . This component provides a <code>variant</code> prop for semantic options.
        You can use the `type` prop to control the component's color in accordance
        with the theme.
      </p>
      <p>
        To control the font size and line height, we use the{" "}
        <code>capHeight</code> and
        <code>lineGap</code> parameter supplied by the <a
          target="_blank"
          href="https://seek-oss.github.io/capsize/"
        >
          capsize
        </a> library.
      </p>
      <p>
        For font sizes, we also use a approach based on the root unit and
        viewport calculation.
      </p>
    </StyledWrapper>
  </Story>
</Canvas>
