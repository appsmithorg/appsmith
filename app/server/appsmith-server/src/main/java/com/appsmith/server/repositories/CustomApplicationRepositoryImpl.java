package com.appsmith.server.repositories;

import com.appsmith.server.acl.AclPermission;
import com.appsmith.server.domains.Application;
import com.appsmith.server.domains.QApplication;
import com.appsmith.server.repositories.ce.CustomApplicationRepositoryCEImpl;
import com.appsmith.server.solutions.ApplicationPermission;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.ReactiveMongoOperations;
import org.springframework.data.mongodb.core.ReactiveMongoTemplate;
import org.springframework.data.mongodb.core.aggregation.AddFieldsOperation;
import org.springframework.data.mongodb.core.aggregation.Aggregation;
import org.springframework.data.mongodb.core.aggregation.ComparisonOperators;
import org.springframework.data.mongodb.core.aggregation.ConditionalOperators;
import org.springframework.data.mongodb.core.aggregation.MatchOperation;
import org.springframework.data.mongodb.core.aggregation.ProjectionOperation;
import org.springframework.data.mongodb.core.convert.MongoConverter;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Flux;

import java.util.Optional;
import java.util.Set;

@Component
@Slf4j
public class CustomApplicationRepositoryImpl extends CustomApplicationRepositoryCEImpl
        implements CustomApplicationRepository {

    private final ReactiveMongoTemplate reactiveMongoTemplate;

    @Autowired
    public CustomApplicationRepositoryImpl(
            @NonNull ReactiveMongoOperations mongoOperations,
            @NonNull MongoConverter mongoConverter,
            CacheableRepositoryHelper cacheableRepositoryHelper,
            ApplicationPermission applicationPermission,
            ReactiveMongoTemplate reactiveMongoTemplate) {
        super(mongoOperations, mongoConverter, cacheableRepositoryHelper, applicationPermission);
        this.reactiveMongoTemplate = reactiveMongoTemplate;
    }

    @Override
    public Flux<Application> findDefaultApplicationsByWorkspaceIds(Set<String> workspaceIds) {
        // Leaving this code commented out for now. Once java starts supporting comparison of two fields in a document
        // while using criteria we can use this code to find the default applications.

        //        Criteria workspaceCriteria = Criteria.where(FieldName.WORKSPACE_ID).in(workspaceIds);
        //        // Filter out the applications which are not connected to git
        //        QGitArtifactMetadata GitArtifactMetadata = QApplication.application.GitArtifactMetadata;
        //        String GitArtifactMetadataPath = fieldName(GitArtifactMetadata);
        //        String defaultBranchName = GitArtifactMetadataPath + "." +
        // fieldName(GitArtifactMetadata.defaultBranchName);
        //        String branchName = GitArtifactMetadataPath + "." + fieldName(GitArtifactMetadata.branchName);
        //
        //        Criteria GitArtifactMetadataCriteria =
        // Criteria.where(fieldName(GitArtifactMetadata)).exists(false);
        //        // Filter out applications where the ssh key is generated by user and the connect app has failed
        //        Criteria notGitArtifactMetadataCriteria = new Criteria()
        //                .andOperator(
        //                        Criteria.where(fieldName(GitArtifactMetadata)).exists(true),
        //                        Criteria.where(defaultBranchName).exists(false),
        //                        Criteria.where(branchName).exists(false)
        //                );
        //
        //        // Filter out applications where the DefaultBranchName is missing due to branch creation flow failures
        // or corrupted scenarios
        //        BasicQuery query = new BasicQuery("{ $expr:  { $eq:  [$" + defaultBranchName + ", $" + branchName +
        // "]} }");
        //
        //        Criteria GitArtifactMetadataDefaultBranchNameCriteria = new Criteria()
        //                .andOperator(
        //                        Criteria.where(fieldName(GitArtifactMetadata)).exists(true),
        //                        Criteria.where(defaultBranchName).exists(true),
        //                        Criteria.where(branchName).exists(true),
        //                        // This criteria is the only way I could figure out to compare 2 fields in the same
        // document
        //
        //                        /*  ***** @Trisha *****
        //                            This is the fixed query. Haven't tested it with actual Git data.
        //                            But it works for applications without Git right now.
        //                        */
        //                        new Criteria()
        ////                        Criteria.where("$expr").is("{ $eq: [$" + defaultBranchName + ", $" + branchName +
        // "]}")
        ////                        Criteria.where("$where").is("this." + defaultBranchName + " == this." + branchName)
        //                );
        //        query.addCriteria(GitArtifactMetadataCriteria);
        //        Criteria gitCriteria = new Criteria()
        //                .orOperator(GitArtifactMetadataCriteria,
        //                        notGitArtifactMetadataCriteria,
        //                        GitArtifactMetadataDefaultBranchNameCriteria);
        //
        //        return queryAllWithoutPermissions(
        //                List.of(workspaceCriteria, gitCriteria),
        //                null,
        //                null,
        //                NO_RECORD_LIMIT
        //        );

        return fetchApplicationUsingAggregation(workspaceIds);
    }

    private Flux<Application> fetchApplicationUsingAggregation(Set<String> workspaceIds) {
        Criteria workspaceIdCriteria = Criteria.where("workspaceId").in(workspaceIds);
        ProjectionOperation projectionOperation = new ProjectionOperation(Application.class);
        MatchOperation workSpaceIdMatchOperation = new MatchOperation(workspaceIdCriteria);
        Criteria isNotDeletedCriteria = notDeleted();
        MatchOperation isNotDeletedMatch = new MatchOperation(isNotDeletedCriteria);
        ComparisonOperators.Eq fieldEQ = ComparisonOperators.Eq.valueOf("$GitArtifactMetadata.defaultBranchName");
        fieldEQ = fieldEQ.equalTo("$GitArtifactMetadata.branchName");
        ConditionalOperators.Cond cond =
                ConditionalOperators.Cond.when(fieldEQ).then(true).otherwise(false);
        AddFieldsOperation addFieldsOperation =
                AddFieldsOperation.addField("isEq").withValue(cond).build();
        Criteria criteria = Criteria.where("isEq").is(true);
        MatchOperation matchOperation = new MatchOperation(criteria);
        Aggregation combinedAggregation = Aggregation.newAggregation(
                projectionOperation, workSpaceIdMatchOperation, isNotDeletedMatch, addFieldsOperation, matchOperation);
        return reactiveMongoTemplate.aggregate(combinedAggregation, Application.class, Application.class);
    }

    @Override
    public Flux<Application> getAllApplicationsInWorkspace(String workspaceId, Optional<AclPermission> aclPermission) {
        Criteria workspaceIdCriteria =
                Criteria.where(fieldName(QApplication.application.workspaceId)).is(workspaceId);
        return queryBuilder()
                .criteria(workspaceIdCriteria)
                .permission(aclPermission.orElse(null))
                .all();
    }
}
